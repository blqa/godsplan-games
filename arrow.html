<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Arrow Zen</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Outfit:wght@400;600;800&display=swap');

        :root {
            --primary: #6366f1;
            --primary-dark: #4f46e5;
            --bg-color: #f8fafc;
            --surface: #ffffff;
            --text-main: #1e293b;
            --text-muted: #94a3b8;
            --danger: #ef4444;
            --success: #10b981;
        }

        body {
            font-family: 'Outfit', sans-serif;
            background-color: var(--bg-color);
            color: var(--text-main);
            touch-action: none;
            overflow: hidden;
            user-select: none;
            -webkit-user-select: none;
            height: 100vh;
            width: 100vw;
            display: flex;
            flex-direction: column;
        }

        /* --- UI ELEMENTS --- */
        .glass-panel {
            background: rgba(255, 255, 255, 0.85);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.5);
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.05), 0 2px 4px -1px rgba(0, 0, 0, 0.03);
        }

        .btn-press {
            transition: transform 0.1s cubic-bezier(0.4, 0, 0.2, 1), background-color 0.2s, opacity 0.2s;
        }
        .btn-press:active {
            transform: scale(0.92);
        }
        .btn-press:disabled {
            opacity: 0.5;
            pointer-events: none;
            transform: none;
        }

        /* --- GAME BOARD --- */
        .game-wrapper {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            padding: 20px;
        }

        .game-board {
            display: grid;
            gap: 8px; /* Espacio fijo entre celdas */
            width: 100%;
            max-width: 360px;
            aspect-ratio: 1; /* Mantiene el tablero cuadrado */
            background: #e2e8f0;
            padding: 12px;
            border-radius: 28px;
            position: relative;
            box-shadow: 
                inset 0 2px 6px rgba(0,0,0,0.06),
                0 20px 25px -5px rgba(0, 0, 0, 0.05);
            
            /* CRITICAL FIX: Force rigid grid tracks */
            grid-auto-rows: minmax(0, 1fr);
            grid-auto-columns: minmax(0, 1fr);
        }

        .grid-cell {
            background-color: var(--surface);
            border-radius: 14px;
            width: 100%;
            height: 100%;
            box-shadow: 0 1px 2px rgba(0,0,0,0.02);
        }

        /* --- ARROWS --- */
        .arrow-container {
            position: relative;
            z-index: 10;
            width: 100%;
            height: 100%;
            pointer-events: none;
            transition: transform 0.2s cubic-bezier(0.34, 1.56, 0.64, 1);
            /* Asegura que el contenedor no expanda el grid */
            min-width: 0;
            min-height: 0;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .arrow-svg {
            width: 100%;
            height: 100%;
            display: block;
            overflow: visible;
            filter: drop-shadow(0px 4px 6px rgba(99, 102, 241, 0.15));
            pointer-events: auto;
            cursor: pointer;
            transition: filter 0.2s;
        }

        .arrow-body {
            fill: var(--primary);
            stroke: var(--primary);
            stroke-width: 12; /* Refined width */
            stroke-linecap: round;
            stroke-linejoin: round;
            transition: fill 0.3s, stroke 0.3s;
        }
        
        .arrow-highlight {
            fill: rgba(255,255,255,0.2);
            stroke: none;
        }

        /* Animations & States */
        .blocked-shake {
            animation: shake 0.4s cubic-bezier(.36,.07,.19,.97) both;
        }

        /* New Bump Animation */
        .blocked-bump {
            animation: bump 0.4s cubic-bezier(0.2, 0.8, 0.2, 1) forwards;
        }
        
        .is-blocking .arrow-body {
            stroke: var(--danger) !important;
            fill: var(--danger) !important;
        }

        .flying-out {
            z-index: 50;
            pointer-events: none !important;
            transition: transform 0.6s cubic-bezier(0.5, 0, 0.1, 1), opacity 0.4s ease-in 0.2s;
            transform: translate(var(--endX), var(--endY)) scale(0.5) !important;
            opacity: 0;
        }

        @keyframes shake {
            10%, 90% { transform: translate3d(-1px, 0, 0); }
            20%, 80% { transform: translate3d(2px, 0, 0); }
            30%, 50%, 70% { transform: translate3d(-3px, 0, 0); }
            40%, 60% { transform: translate3d(3px, 0, 0); }
        }

        @keyframes bump {
            0% { transform: translate(0, 0); }
            40% { transform: translate(var(--bumpX), var(--bumpY)); }
            100% { transform: translate(0, 0); }
        }

        /* --- OVERLAYS --- */
        .modal-overlay {
            position: fixed;
            inset: 0;
            background: rgba(15, 23, 42, 0.4);
            backdrop-filter: blur(4px);
            z-index: 100;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
        }
        .modal-overlay.active {
            opacity: 1;
            pointer-events: auto;
        }

        .modal-card {
            background: white;
            width: 85%;
            max-width: 320px;
            padding: 32px;
            border-radius: 32px;
            text-align: center;
            transform: translateY(20px) scale(0.95);
            transition: transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 8px 10px -6px rgba(0, 0, 0, 0.1);
        }
        .modal-overlay.active .modal-card {
            transform: translateY(0) scale(1);
        }

        .star-icon {
            color: #fbbf24;
            filter: drop-shadow(0 2px 4px rgba(251, 191, 36, 0.3));
            transform: scale(0);
            transition: transform 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        .star-icon.pop { transform: scale(1); }

        #confetti-canvas { position: absolute; pointer-events: none; top: 0; left: 0; width: 100%; height: 100%; z-index: 40; }
        
        /* Loading Spinner */
        .loader {
            width: 40px; height: 40px;
            border: 4px solid #e2e8f0;
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }
        @keyframes spin { to { transform: rotate(360deg); } }

    </style>
</head>
<body>

    <!-- Header UI -->
    <header class="pt-safe-top px-6 py-4 flex justify-between items-center w-full max-w-md mx-auto z-20">
        <div class="flex flex-col">
            <span class="text-xs font-bold text-slate-400 uppercase tracking-widest mb-1">NIVEL</span>
            <span id="level-display" class="text-3xl font-extrabold text-slate-800 leading-none">1</span>
        </div>
        
        <div class="flex gap-3">
            <button onclick="Game.toggleSound()" id="sound-btn" class="btn-press glass-panel w-12 h-12 rounded-2xl flex items-center justify-center text-slate-600">
                <!-- Volume Icon -->
                <svg id="icon-sound-on" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon><path d="M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07"></path></svg>
                <svg id="icon-sound-off" class="hidden" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon><line x1="23" y1="9" x2="17" y2="15"></line><line x1="17" y1="9" x2="23" y2="15"></line></svg>
            </button>
            <button onclick="Game.restartLevel()" class="btn-press glass-panel w-12 h-12 rounded-2xl flex items-center justify-center text-slate-600">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 12"/><path d="M3 3v9h9"/></svg>
            </button>
        </div>
    </header>

    <!-- Game Area -->
    <main class="game-wrapper">
        <canvas id="confetti-canvas"></canvas>
        
        <div id="game-board" class="game-board">
            <!-- Grid Background generated by JS -->
            <div id="grid-bg-layer" class="absolute inset-0 p-3 grid gap-2 z-0 pointer-events-none"></div>
            <!-- Loading Overlay -->
            <div id="loading-overlay" class="absolute inset-0 z-50 flex flex-col items-center justify-center bg-white/90 rounded-3xl backdrop-blur transition-opacity duration-300">
                <div class="loader mb-4"></div>
                <div class="text-sm font-bold text-slate-400 tracking-widest uppercase">Diseñando Puzzle</div>
            </div>
        </div>
    </main>

    <!-- Footer / Hint -->
    <footer class="pb-safe-bottom px-6 py-4 text-center z-10">
        <p id="hint-text" class="text-slate-400 font-medium text-sm">Despeja el tablero (necesitan camino libre)</p>
    </footer>

    <!-- Level Complete Modal -->
    <div id="win-modal" class="modal-overlay">
        <div class="modal-card">
            <div class="flex justify-center gap-2 mb-6">
                <svg class="star-icon w-10 h-10" id="star-1" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"/></svg>
                <svg class="star-icon w-12 h-12 -mt-2" id="star-2" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"/></svg>
                <svg class="star-icon w-10 h-10" id="star-3" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"/></svg>
            </div>
            <h2 class="text-2xl font-extrabold text-slate-800 mb-2">¡Completado!</h2>
            <p class="text-slate-500 mb-8 font-medium">Puzzle resuelto con éxito</p>
            
            <button id="next-lvl-btn" onclick="Game.nextLevel()" class="btn-press w-full py-4 bg-indigo-600 text-white rounded-2xl font-bold text-lg shadow-lg shadow-indigo-200">
                Siguiente Nivel
            </button>
        </div>
    </div>

    <script>
        /**
         * AUDIO SYSTEM (Web Audio API)
         */
        const AudioSys = {
            ctx: null,
            enabled: true,
            init() { if (!this.ctx) this.ctx = new (window.AudioContext || window.webkitAudioContext)(); },
            playTone(freq, type, duration, vol = 0.1) {
                if (!this.enabled || !this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = type;
                osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
                gain.gain.setValueAtTime(vol, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start();
                osc.stop(this.ctx.currentTime + duration);
            },
            pop() { this.init(); if(this.enabled) this.playTone(400, 'sine', 0.15, 0.15); },
            whoosh() { this.init(); this.playTone(300, 'sine', 0.3, 0.05); },
            error() { this.init(); this.playTone(150, 'triangle', 0.15, 0.15); },
            win() {
                this.init();
                setTimeout(() => this.playTone(523.25, 'sine', 0.3, 0.1), 0);
                setTimeout(() => this.playTone(659.25, 'sine', 0.3, 0.1), 100);
                setTimeout(() => this.playTone(783.99, 'sine', 0.6, 0.1), 200);
            }
        };

        const UP=1, RIGHT=2, DOWN=3, LEFT=4;
        
        const Game = {
            gridSize: 5,
            level: 1,
            arrows: [],
            savedArrows: [],
            isAnimating: false,
            // --- FIX START: STATE FLAGS ---
            isLevelComplete: false,
            isProcessingLevel: false,
            // --- FIX END ---

            init() {
                const savedLvl = localStorage.getItem('arrow-puzzle-level');
                if(savedLvl) this.level = parseInt(savedLvl);
                document.getElementById('level-display').innerText = this.level;
                
                // --- GRID SETUP ---
                const bgLayer = document.getElementById('grid-bg-layer');
                const board = document.getElementById('game-board');
                
                const template = `repeat(${this.gridSize}, minmax(0, 1fr))`;
                
                bgLayer.style.gridTemplateColumns = template;
                bgLayer.style.gridTemplateRows = template;
                board.style.gridTemplateColumns = template;
                board.style.gridTemplateRows = template;

                bgLayer.innerHTML = '';
                for(let i=0; i<this.gridSize*this.gridSize; i++) {
                    const div = document.createElement('div');
                    div.className = 'grid-cell';
                    bgLayer.appendChild(div);
                }

                this.generateLevel();
            },

            toggleSound() {
                AudioSys.enabled = !AudioSys.enabled;
                document.getElementById('icon-sound-on').classList.toggle('hidden');
                document.getElementById('icon-sound-off').classList.toggle('hidden');
                AudioSys.init();
            },

            async generateLevel() {
                // --- FIX START: Reset Flags ---
                this.isLevelComplete = false;
                this.isProcessingLevel = false;
                const nextBtn = document.getElementById('next-lvl-btn');
                if(nextBtn) nextBtn.disabled = false;
                // --- FIX END ---

                const overlay = document.getElementById('loading-overlay');
                overlay.classList.remove('opacity-0', 'pointer-events-none');
                
                await new Promise(r => setTimeout(r, 400));
                
                const newArrows = await LevelGenerator.create(this.gridSize, this.level);
                this.arrows = newArrows;
                this.savedArrows = JSON.parse(JSON.stringify(newArrows));
                
                this.render();
                
                overlay.classList.add('opacity-0', 'pointer-events-none');
                
                const hint = document.getElementById('hint-text');
                if(this.level > 5) hint.innerText = "¡Nivel avanzado! Formas complejas";
                else hint.innerText = "Despeja el tablero (necesitan camino libre)";
            },

            restartLevel() {
                if(this.isAnimating) return;
                AudioSys.whoosh();
                this.arrows = JSON.parse(JSON.stringify(this.savedArrows));
                this.render();
            },

            render() {
                const board = document.getElementById('game-board');
                const existingArrows = board.querySelectorAll('.arrow-container');
                existingArrows.forEach(el => el.remove());

                this.arrows.forEach(arrow => {
                    const el = document.createElement('div');
                    el.className = 'arrow-container';
                    el.id = `arrow-${arrow.id}`;
                    
                    el.style.gridRowStart = arrow.bbox.r + 1;
                    el.style.gridRowEnd = `span ${arrow.bbox.h}`;
                    el.style.gridColumnStart = arrow.bbox.c + 1;
                    el.style.gridColumnEnd = `span ${arrow.bbox.w}`;
                    
                    const isSmall = (arrow.occupiedIndices.length === 1);
                    el.style.zIndex = isSmall ? 20 : 10; 

                    const svgContent = Renderer.drawArrow(arrow, this.gridSize);
                    el.innerHTML = svgContent;

                    const svg = el.querySelector('svg');
                    svg.onclick = (e) => {
                        e.stopPropagation();
                        this.handleArrowClick(arrow, el);
                    };

                    board.appendChild(el);
                });
            },

            handleArrowClick(arrow, element) {
                // Ignore input if we already won the level
                if (this.isLevelComplete) return;
                if (this.isAnimating && !this.arrows.find(a=>a.id === arrow.id)) return;

                const { blockers, freeSteps } = Logic.checkPath(arrow, this.arrows, this.gridSize);

                if (blockers.length === 0) {
                    AudioSys.pop();
                    if(navigator.vibrate) navigator.vibrate(10);
                    
                    this.arrows = this.arrows.filter(a => a.id !== arrow.id);
                    
                    let endX = '0px', endY = '0px';
                    const flyDist = '120vh'; 
                    
                    if (arrow.dir === UP) endY = `-${flyDist}`;
                    else if (arrow.dir === DOWN) endY = flyDist;
                    else if (arrow.dir === LEFT) endX = '-100vw';
                    else if (arrow.dir === RIGHT) endX = '100vw';
                    
                    element.style.setProperty('--endX', endX);
                    element.style.setProperty('--endY', endY);
                    element.classList.add('flying-out');

                    const rect = element.getBoundingClientRect();
                    let px = rect.left + rect.width/2;
                    let py = rect.top + rect.height/2;
                    if(arrow.dir === UP) py = rect.top;
                    if(arrow.dir === DOWN) py = rect.bottom;
                    if(arrow.dir === LEFT) px = rect.left;
                    if(arrow.dir === RIGHT) px = rect.right;
                    
                    Effects.burst(px, py, arrow.dir);

                    setTimeout(() => {
                        element.remove();
                        this.checkWin();
                    }, 600);

                } else {
                    AudioSys.error();
                    if(navigator.vibrate) navigator.vibrate(40);
                    
                    let bumpX = '0px', bumpY = '0px';
                    const bumpAmount = (freeSteps > 0) ? 30 : 5; 
                    
                    if (arrow.dir === UP) bumpY = `-${bumpAmount}px`;
                    else if (arrow.dir === DOWN) bumpY = `${bumpAmount}px`;
                    else if (arrow.dir === LEFT) bumpX = `-${bumpAmount}px`;
                    else if (arrow.dir === RIGHT) bumpX = `${bumpAmount}px`;

                    element.style.setProperty('--bumpX', bumpX);
                    element.style.setProperty('--bumpY', bumpY);

                    element.classList.remove('blocked-bump');
                    void element.offsetWidth;
                    element.classList.add('blocked-bump');

                    blockers.forEach(blockerId => {
                        const blockerEl = document.getElementById(`arrow-${blockerId}`);
                        if(blockerEl) {
                            blockerEl.classList.add('is-blocking');
                            setTimeout(() => blockerEl.classList.remove('is-blocking'), 400);
                        }
                    });
                }
            },

            checkWin() {
                // --- FIX START: Prevent double win trigger ---
                if (this.arrows.length === 0 && !this.isLevelComplete) {
                    this.isLevelComplete = true; // Set flag immediately
                    
                    AudioSys.win();
                    if(navigator.vibrate) navigator.vibrate([10, 30, 10]);
                    
                    const modal = document.getElementById('win-modal');
                    modal.classList.add('active');
                    
                    setTimeout(() => document.getElementById('star-1').classList.add('pop'), 100);
                    setTimeout(() => document.getElementById('star-2').classList.add('pop'), 300);
                    setTimeout(() => document.getElementById('star-3').classList.add('pop'), 500);
                }
                // --- FIX END ---
            },

            nextLevel() {
                // --- FIX START: Prevent double click ---
                if (this.isProcessingLevel) return;
                this.isProcessingLevel = true;
                
                const btn = document.getElementById('next-lvl-btn');
                if(btn) btn.disabled = true; // Visual feedback
                // --- FIX END ---

                document.getElementById('win-modal').classList.remove('active');
                document.querySelectorAll('.star-icon').forEach(s => s.classList.remove('pop'));
                
                this.level++;
                localStorage.setItem('arrow-puzzle-level', this.level);
                document.getElementById('level-display').innerText = this.level;
                
                this.generateLevel();
            }
        };

        const Renderer = {
            drawArrow(arrow, gridSize) {
                const minR = arrow.bbox.r;
                const minC = arrow.bbox.c;
                const indices = [...arrow.occupiedIndices];
                
                const points = indices.map(idx => ({
                    x: ((idx % gridSize) - minC) * 100 + 50,
                    y: (Math.floor(idx / gridSize) - minR) * 100 + 50
                }));

                let d = `M ${points[0].x} ${points[0].y}`;
                for(let i=1; i<points.length; i++) {
                    d += ` L ${points[i].x} ${points[i].y}`;
                }

                const head = points[points.length-1];
                let rotation = 0;
                if(arrow.dir === UP) rotation = -90;
                else if(arrow.dir === DOWN) rotation = 90;
                else if(arrow.dir === LEFT) rotation = 180;
                
                const vbW = arrow.bbox.w * 100;
                const vbH = arrow.bbox.h * 100;

                return `
                <svg class="arrow-svg" viewBox="0 0 ${vbW} ${vbH}" preserveAspectRatio="xMidYMid meet">
                    <defs>
                        <mask id="mask-${arrow.id}">
                            <rect x="0" y="0" width="${vbW}" height="${vbH}" fill="white"/>
                        </mask>
                    </defs>
                    <path d="${d}" class="arrow-body" stroke-linecap="round" stroke-linejoin="round" />
                    <g transform="translate(${head.x}, ${head.y}) rotate(${rotation})">
                         <!-- Slightly wider/shorter arrow head for better directionality -->
                        <path d="M -10 -16 L 18 0 L -10 16 Z" fill="var(--primary)" class="arrow-body" stroke="none" />
                    </g>
                    <path d="${d}" class="arrow-highlight" stroke="rgba(255,255,255,0.3)" stroke-width="6" fill="none" transform="translate(-2, -2)" />
                </svg>
                `;
            }
        };

        const Logic = {
            checkPath(arrow, allArrows, gridSize) {
                // --- SNAKE LOGIC FIX ---
                // We only check if the PATH OF THE HEAD is clear.
                // The body follows the head, so we ignore sideways collisions of the body.
                
                const occupiedSet = new Map();
                allArrows.forEach(a => {
                    if (a.id !== arrow.id) {
                        a.occupiedIndices.forEach(idx => occupiedSet.set(idx, a.id));
                    }
                });

                const blockers = new Set();
                let minDistanceToBlocker = 999;

                // Identify Head Index (Last element in occupiedIndices)
                const headIndex = arrow.occupiedIndices[arrow.occupiedIndices.length - 1];
                
                let r = Math.floor(headIndex / gridSize);
                let c = headIndex % gridSize;
                let steps = 0;

                // Move one step forward to start raycasting
                if (arrow.dir === UP) r--;
                else if (arrow.dir === DOWN) r++;
                else if (arrow.dir === LEFT) c--;
                else if (arrow.dir === RIGHT) c++;
                steps++;

                // Trace ray to the edge of the board
                while (r >= 0 && r < gridSize && c >= 0 && c < gridSize) {
                    const idx = r * gridSize + c;
                    if (occupiedSet.has(idx)) {
                        blockers.add(occupiedSet.get(idx));
                        if (steps < minDistanceToBlocker) minDistanceToBlocker = steps;
                    }
                    
                    if (arrow.dir === UP) r--;
                    else if (arrow.dir === DOWN) r++;
                    else if (arrow.dir === LEFT) c--;
                    else if (arrow.dir === RIGHT) c++;
                    steps++;
                }

                return { 
                    blockers: Array.from(blockers), 
                    freeSteps: blockers.size > 0 ? Math.max(0, minDistanceToBlocker - 1) : 999 
                };
            },

            // Only used by generator
            isSolvable(testArrows, gridSize) {
                let simArrows = JSON.parse(JSON.stringify(testArrows));
                let changed = true;
                while (changed && simArrows.length > 0) {
                    changed = false;
                    const indexToRemove = simArrows.findIndex(a => this.checkPath(a, simArrows, gridSize).blockers.length === 0);
                    if (indexToRemove !== -1) {
                        simArrows.splice(indexToRemove, 1);
                        changed = true;
                    }
                }
                return simArrows.length === 0;
            }
        };

        const LevelGenerator = {
            async create(gridSize, level) {
                return new Promise(resolve => {
                    setTimeout(() => {
                        const density = 0.65;
                        const maxLen = level < 3 ? 2 : (level < 6 ? 4 : 5);
                        const allowTurns = level >= 2;
                        
                        let valid = false;
                        let resultArrows = [];
                        let attempts = 0;

                        while (!valid && attempts < 2000) {
                            resultArrows = [];
                            let occupied = new Set();
                            let idCounter = 1;
                            
                            let indices = Array.from({length: gridSize*gridSize}, (_, i) => i);
                            indices.sort(() => Math.random() - 0.5);

                            for (let i of indices) {
                                if (occupied.has(i)) continue;
                                if (Math.random() > density) continue;

                                const dir = Math.floor(Math.random() * 4) + 1;
                                let body = [i];
                                let head = {r: Math.floor(i/gridSize), c: i%gridSize};
                                let backDir = dir === UP ? DOWN : (dir === DOWN ? UP : (dir === LEFT ? RIGHT : LEFT));
                                
                                const len = Math.floor(Math.random() * maxLen) + 1;
                                let cr = head.r, cc = head.c;
                                let curBackDir = backDir;

                                for (let l=0; l<len; l++) {
                                    if(allowTurns && l > 0 && Math.random() > 0.6) {
                                        if(curBackDir === UP || curBackDir === DOWN) curBackDir = Math.random()>0.5 ? LEFT : RIGHT;
                                        else curBackDir = Math.random()>0.5 ? UP : DOWN;
                                    }
                                    
                                    let nr = cr, nc = cc;
                                    if(curBackDir === UP) nr--;
                                    else if(curBackDir === DOWN) nr++;
                                    else if(curBackDir === LEFT) nc--;
                                    else if(curBackDir === RIGHT) nc++;

                                    if(nr>=0 && nr<gridSize && nc>=0 && nc<gridSize) {
                                        const nidx = nr*gridSize+nc;
                                        if(!occupied.has(nidx) && !body.includes(nidx)) {
                                            body.push(nidx);
                                            cr=nr; cc=nc;
                                        } else break;
                                    } else break;
                                }

                                if(body.every(x => !occupied.has(x))) {
                                    body.forEach(x => occupied.add(x));
                                    const rs = body.map(x=>Math.floor(x/gridSize));
                                    const cs = body.map(x=>x%gridSize);
                                    
                                    resultArrows.push({
                                        id: idCounter++,
                                        dir: dir,
                                        occupiedIndices: body.reverse(),
                                        bbox: {
                                            r: Math.min(...rs), c: Math.min(...cs),
                                            w: Math.max(...cs)-Math.min(...cs)+1,
                                            h: Math.max(...rs)-Math.min(...rs)+1
                                        }
                                    });
                                }
                            }
                            
                            if (resultArrows.length > 3 && Logic.isSolvable(resultArrows, gridSize)) {
                                valid = true;
                            }
                            attempts++;
                        }
                        
                        // Fallback
                        if (!valid) {
                             resultArrows = [
                                {id:1, dir:UP, occupiedIndices:[17,12], bbox:{r:2,c:2,w:1,h:2}},
                                {id:2, dir:LEFT, occupiedIndices:[11], bbox:{r:2,c:1,w:1,h:1}},
                                {id:3, dir:RIGHT, occupiedIndices:[13], bbox:{r:2,c:3,w:1,h:1}}
                            ];
                        }
                        
                        resolve(resultArrows);
                    }, 0);
                });
            }
        };

        const Effects = {
            canvas: document.getElementById('confetti-canvas'),
            ctx: document.getElementById('confetti-canvas').getContext('2d'),
            particles: [],
            
            init() {
                this.resize();
                window.addEventListener('resize', () => this.resize());
                this.loop();
            },
            
            resize() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
            },

            burst(x, y, dir) {
                const count = 20;
                const colors = ['#6366f1', '#a855f7', '#3b82f6', '#cbd5e1'];
                let baseVx = 0, baseVy = 0;
                if(dir === UP) baseVy = -5;
                if(dir === DOWN) baseVy = 5;
                if(dir === LEFT) baseVx = -5;
                if(dir === RIGHT) baseVx = 5;

                for(let i=0; i<count; i++) {
                    this.particles.push({
                        x: x, y: y,
                        vx: (Math.random() - 0.5) * 10 + baseVx,
                        vy: (Math.random() - 0.5) * 10 + baseVy,
                        color: colors[Math.floor(Math.random() * colors.length)],
                        size: Math.random() * 6 + 4,
                        life: 1.0,
                        decay: Math.random() * 0.03 + 0.01
                    });
                }
            },

            loop() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                for(let i=this.particles.length-1; i>=0; i--) {
                    const p = this.particles[i];
                    p.x += p.vx; p.y += p.vy; p.vy += 0.5; p.vx *= 0.95; p.life -= p.decay;
                    this.ctx.globalAlpha = p.life;
                    this.ctx.fillStyle = p.color;
                    this.ctx.beginPath();
                    this.ctx.roundRect(p.x, p.y, p.size, p.size, 2);
                    this.ctx.fill();
                    if(p.life <= 0) this.particles.splice(i, 1);
                }
                requestAnimationFrame(() => this.loop());
            }
        };

        Effects.init();
        Game.init();

    </script>
</body>
</html>
