<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Arrow Puzzle - Clean UX</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=DM+Sans:wght@500;700&display=swap');

        body {
            font-family: 'DM Sans', sans-serif;
            background-color: #f3f4f6;
            touch-action: none;
            overflow: hidden;
            user-select: none;
            -webkit-user-select: none;
            color: #111827;
        }

        /* Contenedor del tablero */
        .game-container {
            display: grid;
            gap: 6px; 
            width: 100%;
            max-width: 380px;
            aspect-ratio: 1;
            margin: 0 auto;
            background: #e5e7eb; /* Gris neutro suave */
            padding: 8px;
            border-radius: 24px;
            position: relative;
            transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
            box-shadow: 
                0 10px 15px -3px rgba(0, 0, 0, 0.1), 
                0 4px 6px -2px rgba(0, 0, 0, 0.05),
                inset 0 2px 4px rgba(0,0,0,0.05);
        }

        /* Celdas de fondo */
        .grid-bg-cell {
            background-color: #ffffff;
            border-radius: 10px;
            width: 100%;
            height: 100%;
            box-shadow: 0 1px 2px rgba(0,0,0,0.03);
        }

        /* CONTENEDOR DE FLECHA */
        .arrow-item {
            position: relative;
            z-index: 20;
            display: flex;
            align-items: center;
            justify-content: center;
            -webkit-tap-highlight-color: transparent;
            /* Permite clickear A TRAVÉS de los huecos vacíos del div */
            pointer-events: none; 
            transition: transform 0.15s ease-out;
        }

        /* SVG */
        .arrow-svg {
            width: 100%;
            height: 100%;
            overflow: visible;
            /* Sombra suave y elevada */
            filter: drop-shadow(0px 4px 3px rgba(0,0,0,0.15));
            /* Captura clicks solo en la línea dibujada */
            pointer-events: visiblePainted; 
            cursor: pointer;
            transition: filter 0.2s;
        }

        /* Estilo de la línea */
        .arrow-path {
            fill: none;
            stroke: #1f2937; /* Gray-800: Negro suave, menos agresivo */
            stroke-width: 22; /* Más grueso para presencia visual */
            stroke-linecap: round;
            stroke-linejoin: round;
            transition: stroke 0.2s;
        }

        /* Estado Bloqueado (Rojo) */
        .blocked .arrow-path {
            stroke: #ef4444; /* Rojo error */
        }
        
        /* Animación Shake (Error) */
        @keyframes shake {
            0%, 100% { transform: translate(0, 0); }
            15% { transform: translate(-4px, 0); }
            30% { transform: translate(4px, 0); }
            45% { transform: translate(-4px, 0); }
            60% { transform: translate(4px, 0); }
        }
        .shake-anim {
            animation: shake 0.4s ease-in-out;
        }

        /* Animaciones de Salida */
        /* Usamos 'forwards' para mantener el estado final */
        @keyframes flyOut {
            0% { transform: translate(0,0) scale(1); opacity: 1; }
            40% { transform: translate(var(--tx), var(--ty)) scale(0.9); opacity: 1; }
            100% { transform: translate(var(--endX), var(--endY)) scale(1.1); opacity: 0; }
        }

        .flying {
            /* Las variables CSS se setean en JS según dirección */
            animation: flyOut 0.5s cubic-bezier(0.16, 1, 0.3, 1) forwards;
            pointer-events: none !important;
            z-index: 50;
        }

        .ui-panel {
            background: white;
            border-radius: 20px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.03);
            border: 1px solid #f3f4f6;
        }

        .btn-icon {
            transition: all 0.2s;
        }
        .btn-icon:active { transform: scale(0.92); }

        .loader {
            width: 32px; height: 32px;
            border: 4px solid #e5e7eb;
            border-top-color: #111827;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }
        @keyframes spin { to { transform: rotate(360deg); } }

        #confetti-canvas {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 100;
        }
    </style>
</head>
<body class="flex flex-col items-center justify-center min-h-screen p-4 text-slate-800">
    <canvas id="confetti-canvas"></canvas>

    <header class="text-center mb-6">
        <h1 class="text-4xl font-bold tracking-tight text-slate-900">Arrow Puzzle</h1>
        <p class="text-slate-400 text-xs font-bold tracking-widest mt-1 uppercase">Clean Edition</p>
    </header>

    <!-- UI Stats -->
    <div class="ui-panel flex justify-between items-center w-full max-w-[380px] mb-6 p-4">
        <div class="flex items-center gap-4">
            <div>
                <span class="block text-[10px] text-slate-400 font-bold uppercase tracking-wider">Nivel</span>
                <span id="level-num" class="text-3xl font-bold leading-none text-slate-800">1</span>
            </div>
            <div class="h-8 w-px bg-slate-100"></div>
            <div>
                 <span class="block text-[10px] text-slate-400 font-bold uppercase tracking-wider">Tablero</span>
                 <span id="grid-size-display" class="text-sm font-bold text-slate-500">5x5</span>
            </div>
        </div>
        
        <div class="flex gap-2">
            <button onclick="resetLevel()" class="btn-icon w-11 h-11 flex items-center justify-center rounded-xl bg-slate-50 hover:bg-slate-100 text-slate-600">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 12"/><path d="M3 3v9h9"/></svg>
            </button>
            <button onclick="generateNewLevel()" class="btn-icon w-11 h-11 flex items-center justify-center rounded-xl bg-slate-900 hover:bg-slate-800 text-white shadow-lg shadow-slate-900/20">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M5 12h14"/><path d="m12 5 7 7-7 7"/></svg>
            </button>
        </div>
    </div>

    <!-- Game Board -->
    <div id="game-board" class="game-container">
        <!-- Overlay de carga -->
        <div class="absolute inset-0 flex items-center justify-center bg-white/80 backdrop-blur-sm z-50 rounded-2xl hidden transition-opacity duration-300" id="loading-overlay">
            <div class="text-center">
                <div class="loader mx-auto mb-3"></div>
                <span class="text-xs font-bold text-slate-400 uppercase tracking-widest">Generando...</span>
            </div>
        </div>
    </div>

    <div class="mt-8 text-center max-w-[280px] opacity-60">
        <p class="text-slate-500 text-xs font-medium" id="hint-text">
            Toca las flechas para liberarlas.
        </p>
    </div>

    <script>
        // --- CONSTANTES ---
        const UP = 1, RIGHT = 2, DOWN = 3, LEFT = 4;
        
        // --- ESTADO ---
        let gridSize = 5;
        let arrows = [];
        let currentLevel = 1;
        let savedArrows = []; 

        // --- LÓGICA DE SOLUCIÓN (RAYCASTING) ---
        function canEscape(arrow, allArrows) {
            // Mapa de celdas ocupadas por OTRAS flechas
            const occupied = new Set();
            allArrows.forEach(a => {
                if (a.id !== arrow.id) {
                    a.occupiedIndices.forEach(idx => occupied.add(idx));
                }
            });

            // Verificar cada segmento de la flecha
            for (let cellIndex of arrow.occupiedIndices) {
                if (!checkRay(cellIndex, arrow.dir, occupied)) return false;
            }
            return true;
        }

        function checkRay(startIndex, dir, occupiedSet) {
            let r = Math.floor(startIndex / gridSize);
            let c = startIndex % gridSize;
            
            // Mover un paso inicial
            if (dir === UP) r--;
            else if (dir === DOWN) r++;
            else if (dir === LEFT) c--;
            else if (dir === RIGHT) c++;

            while (r >= 0 && r < gridSize && c >= 0 && c < gridSize) {
                const idx = r * gridSize + c;
                if (occupiedSet.has(idx)) return false; 
                
                if (dir === UP) r--;
                else if (dir === DOWN) r++;
                else if (dir === LEFT) c--;
                else if (dir === RIGHT) c++;
            }
            return true;
        }

        function isSolvable(testArrows) {
            let simArrows = JSON.parse(JSON.stringify(testArrows));
            let changed = true;
            while (changed && simArrows.length > 0) {
                changed = false;
                const indexToRemove = simArrows.findIndex(a => canEscape(a, simArrows));
                if (indexToRemove !== -1) {
                    simArrows.splice(indexToRemove, 1);
                    changed = true;
                }
            }
            return simArrows.length === 0;
        }

        // --- GENERADOR DE NIVELES ---
        async function createValidLevel(level) {
            return new Promise(resolve => {
                setTimeout(() => {
                    // Dificultad progresiva
                    let newSize = 5;
                    if (level >= 4) newSize = 6;
                    if (level >= 8) newSize = 7;
                    gridSize = newSize;

                    const density = 0.60; // Un poco menos denso para que sea elegante
                    const allowTurns = level >= 3; 
                    const maxLen = level < 3 ? 2 : (level < 6 ? 3 : 5);
                    
                    let valid = false;
                    let newArrows = [];
                    let attempts = 0;
                    
                    while (!valid && attempts < 3000) {
                        newArrows = [];
                        let occupied = new Set();
                        let idCounter = 1;
                        
                        // Lista aleatoria de celdas para intentar iniciar flechas
                        let indicesToCheck = Array.from({length: gridSize*gridSize}, (_, i) => i);
                        indicesToCheck.sort(() => Math.random() - 0.5);

                        for (let i of indicesToCheck) {
                            if (occupied.has(i)) continue;
                            if (Math.random() > density) continue;

                            const dir = Math.floor(Math.random() * 4) + 1;
                            
                            // Construcción del cuerpo: "Crecimiento inverso"
                            // Empezamos en la cabeza (i) y añadimos cola hacia atrás
                            let bodyIndices = [i]; 
                            let currentHead = {r: Math.floor(i/gridSize), c: i%gridSize};
                            
                            // Dirección inicial hacia atrás (opuesta al movimiento)
                            let backDir = dir === UP ? DOWN : (dir === DOWN ? UP : (dir === LEFT ? RIGHT : LEFT));
                            
                            const targetLen = Math.floor(Math.random() * maxLen) + 1;
                            let currR = currentHead.r;
                            let currC = currentHead.c;
                            let currentBackDir = backDir;

                            for (let l = 0; l < targetLen; l++) {
                                // Giro aleatorio
                                if (allowTurns && l > 0 && Math.random() > 0.6) {
                                    if (currentBackDir === UP || currentBackDir === DOWN) {
                                        currentBackDir = Math.random() > 0.5 ? LEFT : RIGHT;
                                    } else {
                                        currentBackDir = Math.random() > 0.5 ? UP : DOWN;
                                    }
                                }

                                let nextR = currR, nextC = currC;
                                if (currentBackDir === UP) nextR--;
                                else if (currentBackDir === DOWN) nextR++;
                                else if (currentBackDir === LEFT) nextC--;
                                else if (currentBackDir === RIGHT) nextC++;

                                if (nextR >= 0 && nextR < gridSize && nextC >= 0 && nextC < gridSize) {
                                    const nextIdx = nextR * gridSize + nextC;
                                    if (!occupied.has(nextIdx) && !bodyIndices.includes(nextIdx)) {
                                        bodyIndices.push(nextIdx);
                                        currR = nextR;
                                        currC = nextC;
                                    } else break;
                                } else break;
                            }

                            if (bodyIndices.every(idx => !occupied.has(idx))) {
                                bodyIndices.forEach(idx => occupied.add(idx));
                                
                                // Calc Bounding Box
                                const rs = bodyIndices.map(idx => Math.floor(idx/gridSize));
                                const cs = bodyIndices.map(idx => idx%gridSize);
                                const minR = Math.min(...rs); const maxR = Math.max(...rs);
                                const minC = Math.min(...cs); const maxC = Math.max(...cs);

                                newArrows.push({
                                    id: idCounter++,
                                    dir: dir,
                                    headIndex: i,
                                    // IMPORTANTE: bodyIndices[0] es la cabeza. El resto es cola.
                                    occupiedIndices: bodyIndices, 
                                    bbox: { r: minR, c: minC, w: maxR-minR+1, h: maxC-minC+1 }
                                });
                            }
                        }

                        if (newArrows.length >= 4 && isSolvable(newArrows)) valid = true;
                        attempts++;
                    }
                    resolve(valid ? newArrows : createFallbackLevel());
                }, 10);
            });
        }

        function createFallbackLevel() {
            gridSize = 5;
            return [
                {id:1, dir:UP, headIndex:12, occupiedIndices:[12,17], bbox:{r:2,c:2,w:1,h:2}},
                {id:2, dir:LEFT, headIndex:11, occupiedIndices:[11], bbox:{r:2,c:1,w:1,h:1}},
                {id:3, dir:RIGHT, headIndex:13, occupiedIndices:[13], bbox:{r:2,c:3,w:1,h:1}}
            ];
        }

        // --- RENDERIZADO SVG PERFECTO ---
        function generateArrowPath(arrow) {
            const minR = arrow.bbox.r;
            const minC = arrow.bbox.c;
            
            // Invertimos el array para dibujar desde la COLA hacia la CABEZA
            // arrow.occupiedIndices = [Cabeza, Cuello, ..., Cola]
            // puntos = [Cola, ..., Cuello, Cabeza]
            const indices = [...arrow.occupiedIndices].reverse();
            
            const points = indices.map(idx => ({
                x: ((idx % gridSize) - minC) * 100 + 50,
                y: (Math.floor(idx / gridSize) - minR) * 100 + 50
            }));

            if (points.length === 0) return "";

            // 1. Dibujar el cuerpo (Polyline)
            let d = `M ${points[0].x} ${points[0].y}`;
            for(let i=1; i<points.length; i++) {
                d += ` L ${points[i].x} ${points[i].y}`;
            }

            // 2. Dibujar la punta en el último punto (Cabeza)
            const head = points[points.length-1];
            
            // Ángulo según dirección de movimiento
            let angle = 0;
            if (arrow.dir === UP) angle = -90;
            else if (arrow.dir === DOWN) angle = 90;
            else if (arrow.dir === LEFT) angle = 180;
            else if (arrow.dir === RIGHT) angle = 0;
            
            const tipLen = 35; // Punta un poco más larga y estilizada
            const rad = angle * Math.PI / 180;
            const wingAngle = 0.6; // Ángulo de apertura de las alas
            
            const p1x = head.x - tipLen * Math.cos(rad - wingAngle);
            const p1y = head.y - tipLen * Math.sin(rad - wingAngle);
            const p2x = head.x - tipLen * Math.cos(rad + wingAngle);
            const p2y = head.y - tipLen * Math.sin(rad + wingAngle);
            
            // Path combinado: Cuerpo + Punta
            // Usamos M para movernos a la cabeza y dibujar las "alas" de la flecha
            const arrowHead = ` M ${head.x} ${head.y} L ${p1x} ${p1y} M ${head.x} ${head.y} L ${p2x} ${p2y}`;
            
            return `<path d="${d}${arrowHead}" class="arrow-path" />`;
        }

        function renderBoard() {
            const board = document.getElementById('game-board');
            const overlay = document.getElementById('loading-overlay');
            board.innerHTML = '';
            board.appendChild(overlay);

            board.style.gridTemplateColumns = `repeat(${gridSize}, 1fr)`;
            board.style.gridTemplateRows = `repeat(${gridSize}, 1fr)`;
            document.getElementById('grid-size-display').innerText = `${gridSize}x${gridSize}`;

            // Fondo
            for(let i=0; i<gridSize*gridSize; i++) {
                const bg = document.createElement('div');
                bg.className = 'grid-bg-cell';
                board.appendChild(bg);
            }

            // Flechas
            arrows.forEach(arrow => {
                const el = document.createElement('div');
                el.className = 'arrow-item';
                
                el.style.gridRowStart = arrow.bbox.r + 1;
                el.style.gridRowEnd = `span ${arrow.bbox.h}`;
                el.style.gridColumnStart = arrow.bbox.c + 1;
                el.style.gridColumnEnd = `span ${arrow.bbox.w}`;
                
                const vbW = arrow.bbox.w * 100;
                const vbH = arrow.bbox.h * 100;
                
                el.innerHTML = `
                    <svg class="arrow-svg" viewBox="0 0 ${vbW} ${vbH}" preserveAspectRatio="xMidYMid meet">
                        ${generateArrowPath(arrow)}
                    </svg>
                `;

                // Interacción
                const svgEl = el.querySelector('svg');
                svgEl.onclick = (e) => {
                    e.stopPropagation();
                    handleArrowClick(arrow, el, svgEl);
                };

                board.appendChild(el);
            });
        }

        function handleArrowClick(arrow, element, svgElement) {
            if (!arrows.find(a => a.id === arrow.id)) return;

            if (canEscape(arrow, arrows)) {
                // Éxito
                arrows = arrows.filter(a => a.id !== arrow.id);
                
                // Configurar animación de salida
                let endX = '0px', endY = '0px';
                if (arrow.dir === UP) endY = '-150vh';
                else if (arrow.dir === DOWN) endY = '150vh';
                else if (arrow.dir === LEFT) endX = '-150vw';
                else if (arrow.dir === RIGHT) endX = '150vw';

                element.style.setProperty('--tx', (arrow.dir === LEFT || arrow.dir === RIGHT) ? (arrow.dir === LEFT ? '-20px' : '20px') : '0px');
                element.style.setProperty('--ty', (arrow.dir === UP || arrow.dir === DOWN) ? (arrow.dir === UP ? '-20px' : '20px') : '0px');
                element.style.setProperty('--endX', endX);
                element.style.setProperty('--endY', endY);

                element.classList.add('flying');
                if (navigator.vibrate) navigator.vibrate(10);

                setTimeout(() => {
                    element.remove();
                    checkWin();
                }, 500);

            } else {
                // Bloqueado (UIX Mejorada)
                element.classList.remove('shake-anim');
                svgElement.classList.add('blocked'); // Cambia color a rojo
                
                void element.offsetWidth; // Reflow
                
                element.classList.add('shake-anim');
                if (navigator.vibrate) navigator.vibrate(50);
                
                // Quitar color rojo después de un momento
                setTimeout(() => {
                    svgElement.classList.remove('blocked');
                }, 400);
            }
        }

        async function init() {
            await generateNewLevel();
        }

        async function generateNewLevel() {
            document.getElementById('loading-overlay').classList.remove('hidden');
            const newArrows = await createValidLevel(currentLevel);
            arrows = newArrows;
            savedArrows = JSON.parse(JSON.stringify(newArrows));
            renderBoard();
            
            // Delay para que se vea el loader y la transición sea suave
            setTimeout(() => {
                document.getElementById('loading-overlay').classList.add('hidden');
            }, 300);
            
            document.getElementById('level-num').innerText = currentLevel;
            
            const hint = document.getElementById('hint-text');
            if (currentLevel >= 6) hint.innerText = "¡Nuevas formas complejas!";
            else if (currentLevel >= 4) hint.innerText = "El espacio se expande.";
            else hint.innerText = "Toca para liberar. Si tiembla, está bloqueada.";
        }

        function resetLevel() {
            if (savedArrows.length > 0) {
                arrows = JSON.parse(JSON.stringify(savedArrows));
                renderBoard();
            }
        }

        function checkWin() {
            if (arrows.length === 0) {
                fireConfetti();
                setTimeout(() => {
                    currentLevel++;
                    generateNewLevel();
                }, 1200);
            }
        }

        function fireConfetti() {
            const canvas = document.getElementById('confetti-canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            const particles = Array.from({length: 120}, () => ({
                x: window.innerWidth/2, y: window.innerHeight/2,
                vx: (Math.random()-0.5)*30, vy: (Math.random()-0.5)*30,
                color: ['#1e293b', '#3b82f6', '#10b981'][Math.floor(Math.random()*3)], 
                life: 1, 
                size: Math.random()*8+3
            }));

            function draw() {
                ctx.clearRect(0,0,canvas.width,canvas.height);
                let alive = false;
                particles.forEach(p => {
                    if(p.life>0){
                        alive=true; p.x+=p.vx; p.y+=p.vy; p.vy+=0.8; p.life-=0.02;
                        ctx.fillStyle=p.color; ctx.globalAlpha=p.life;
                        ctx.fillRect(p.x,p.y,p.size,p.size);
                    }
                });
                if(alive) requestAnimationFrame(draw);
            }
            draw();
        }

        init();
    </script>
</body>
</html>
